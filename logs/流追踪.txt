    00000000  00 00 00 14 00 09 00 09  00 00 00 08 00 00 00 00   ........ ........   
    00000010  00 04 93 e0     
	[0 0 0 20 0 9 0 9 0 0 0 8 0 0 0 0 0 4 147 224]
	主机是小端序的cpu并以大端序传输,低位的放到了后面高位在数组前面
	
	00000000  14 00 00 00 09 00 09 00  08 00 00 00 e0 93 04 00   ........ ........
    00000010  00 00 00 00                                        ....
	[20 0 0 0 9 0 9 0 8 0 0 0 224 147 4 0 0 0 0 0]
	以小端序发送
	
	
	00000000  14 00 00 00 b8 88 b8 88  08 00 00 00 e0 93 04 00   ........ ........
    00000010  00 00 00 00   
	[20 0 0 0 184 136 184 136 8 0 0 0 224 147 4 0 0 0 0 0]
	                                     ....
	
	这么处理主要是争对跨平台网络传输
	主机序转为网络字节序，就是低位移到高，高位移到低
	网络字节序转为主机字节序，就是高位移到低，低位移到高恰恰相反
	
	源是小端->目标小端 
	当源主机是小端序->按小端序发送[不变字节位置]   
		socket流的数据是小端序的,目标主机收到流    
	当目标主机是小端序->就可以用小端序解析[不变字节位置] 

	当源主机是小端序->按大端序发送[反转位置]   
		socket流的数据是大端序的,目标主机收到流    
	当目标主机是小端序->就需要用大端序解析[改变字节位置]
	
	源是小端->目标大端
	当源主机是小端序->按小端序发送[不变字节位置] 
			socket流的数据是小端序的,目标主机收到流    
	当目标主机是大端序->就可以用大端序解析[改变] 

	当源主机是小端序->按大端序发送[反转字节位置] 
			socket流的数据是大端序的,目标主机收到流    
	当目标主机是大端序->就可以用小端序解析[不改变] 
	
	源是大端->目标小端
	当源主机是大端序->按小端序发送[不变字节位置] 
		socket流的数据是大端序的,目标主机收到流 
	当目标主机是小端序->就需要用大端序解析[反转位置] 可以解
	
	当源主机是大端序->按大端序发送[改变字节位置] 
		socket流的数据是小端,目标主机收到流 
	当目标主机是小端序->就需要用小端序解析[不变字节位置]
	
	源是大端->目标大端
	当源主机是大端序->按小端序发送[不改变] 
		socket流的数据是大端,目标主机收到流 
	当目标主机是大端序->就需要用小端序解析[不变字节位置]
	
	源是大端->目标大端
	当源主机是大端序->按大端序发送[改变字节位置] 
		socket流的数据是小端,目标主机收到流 
	当目标主机是大端序->就需要用大端序解析[改变字节位置]
	
	所以默认先按小端弄就是
	[0 0 0 20 0 9 0 9 0 0 0 8 0 0 0 0 0 4 147 224]
	[20 0 0 0 9 0 9 0 8 0 0 0 224 147 4 0 0 0 0 0]